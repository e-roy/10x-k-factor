import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { db } from "@/db";
import { tutorSessions, challenges } from "@/db/schema";
import { randomUUID } from "crypto";

interface CreateSessionRequest {
  transcript: string;
  summary: string;
  subject: string;
  tutorId?: string; // optional for simulated sessions
  duration?: number;
}

/**
 * Create a tutor session and trigger challenge generation
 * POST /api/tutor-sessions/create
 */
export async function POST(req: NextRequest) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body: CreateSessionRequest = await req.json();
    const { transcript, summary, subject, tutorId, duration } = body;

    if (!transcript || !summary || !subject) {
      return NextResponse.json(
        { error: "transcript, summary, and subject are required" },
        { status: 400 }
      );
    }

    const sessionId = randomUUID();
    const studentId = session.user.id;

    // Insert tutor session
    await db.insert(tutorSessions).values({
      id: sessionId,
      studentId,
      tutorId: tutorId || null,
      subject,
      transcript,
      summary,
      duration: duration || null,
      metadata: {
        generatedBy: "api",
        isSimulated: !tutorId,
      },
    });

    // Trigger challenge generation via Loop Orchestrator
    const challengeId = await generateChallengeFromSession({
      sessionId,
      studentId,
      subject,
      summary,
    });

    return NextResponse.json({
      sessionId,
      challengeId,
      message: "Tutor session created and challenge generated",
    });
  } catch (error) {
    console.error("[create-tutor-session] Error:", error);
    return NextResponse.json(
      { error: "Failed to create tutor session" },
      { status: 500 }
    );
  }
}

/**
 * Generate challenge from tutor session
 * This simulates what the Loop Orchestrator would do when it hears about a new session
 */
async function generateChallengeFromSession(params: {
  sessionId: string;
  studentId: string;
  subject: string;
  summary: string;
}): Promise<string> {
  const { sessionId, studentId, subject, summary } = params;

  // Generate questions using LLM
  const questions = await generateQuestions(summary, subject);

  const challengeId = randomUUID();
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 7); // Challenge expires in 7 days

  // Insert challenge
  await db.insert(challenges).values({
    id: challengeId,
    sessionId,
    userId: studentId,
    subject,
    questions,
    difficulty: "medium",
    status: "pending",
    expiresAt,
    loop: "buddy_challenge", // Default loop for now
    metadata: {
      generatedFrom: "tutor_session",
      autoGenerated: true,
    },
  });

  return challengeId;
}

/**
 * Generate quiz questions from session summary
 */
async function generateQuestions(
  summary: string,
  subject: string
): Promise<
  Array<{
    question: string;
    options: string[];
    correctAnswer: number;
    explanation?: string;
  }>
> {
  const USE_OLLAMA = process.env.LLM_PROVIDER === "ollama";
  const prompt = `Based on this tutoring session summary for ${subject}, generate 5 multiple-choice reinforcement questions.

Summary:
${summary}

Generate questions that test understanding of the key concepts covered. For each question:
1. Write a clear question
2. Provide 4 answer options (A, B, C, D)
3. Indicate which option is correct (0-3 index)
4. Include a brief explanation

Format your response as a JSON array with this structure:
[
  {
    "question": "What is the standard form of a quadratic equation?",
    "options": ["ax + b = 0", "ax² + bx + c = 0", "y = mx + b", "a² + b² = c²"],
    "correctAnswer": 1,
    "explanation": "The standard form is ax² + bx + c = 0, where a ≠ 0."
  }
]

Respond ONLY with the JSON array, no additional text.`;

  try {
    let response: string;
    
    if (USE_OLLAMA) {
      response = await generateWithOllama(prompt);
    } else {
      response = await generateWithOpenAI(prompt);
    }

    // Parse JSON response
    const cleaned = response.trim().replace(/```json\n?/g, "").replace(/```\n?/g, "");
    const questions = JSON.parse(cleaned);
    
    return questions;
  } catch (error) {
    console.error("[generateQuestions] Error:", error);
    // Return fallback questions
    return generateFallbackQuestions(subject);
  }
}

async function generateWithOllama(prompt: string): Promise<string> {
  const OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL || "http://localhost:11434";
  
  const response = await fetch(`${OLLAMA_BASE_URL}/api/generate`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: "llama3.2",
      prompt,
      stream: false,
      options: {
        temperature: 0.7,
      },
    }),
  });

  if (!response.ok) {
    throw new Error(`Ollama API error: ${response.statusText}`);
  }

  const data = await response.json();
  return data.response;
}

async function generateWithOpenAI(prompt: string): Promise<string> {
  const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
  
  if (!OPENAI_API_KEY) {
    throw new Error("OpenAI API key not configured");
  }

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${OPENAI_API_KEY}`,
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You are a helpful assistant that generates educational quiz questions. Always respond with valid JSON only.",
        },
        {
          role: "user",
          content: prompt,
        },
      ],
      temperature: 0.7,
      max_tokens: 1500,
    }),
  });

  if (!response.ok) {
    throw new Error(`OpenAI API error: ${response.statusText}`);
  }

  const data = await response.json();
  return data.choices[0].message.content;
}

function generateFallbackQuestions(subject: string): Array<{
  question: string;
  options: string[];
  correctAnswer: number;
  explanation?: string;
}> {
  return [
    {
      question: `What is the main focus of this ${subject} session?`,
      options: [
        "Basic arithmetic",
        "Advanced concepts covered in the session",
        "Historical context",
        "Unrelated topics",
      ],
      correctAnswer: 1,
      explanation: "The session focused on the advanced concepts discussed with the tutor.",
    },
    {
      question: "Which strategy is most effective for solving the problems discussed?",
      options: [
        "Guessing randomly",
        "Applying the methods demonstrated in the session",
        "Skipping difficult questions",
        "Memorizing without understanding",
      ],
      correctAnswer: 1,
      explanation: "Using the demonstrated methods ensures proper understanding and application.",
    },
    {
      question: "What is a key takeaway from the tutoring session?",
      options: [
        "There's nothing important to remember",
        "Understanding the fundamental concepts covered",
        "Only memorize the answers",
        "Avoid practicing these topics",
      ],
      correctAnswer: 1,
      explanation: "The fundamental concepts form the basis for solving related problems.",
    },
    {
      question: "How should you approach similar problems in the future?",
      options: [
        "Randomly try different methods",
        "Use the systematic approach taught in the session",
        "Give up immediately",
        "Copy from others",
      ],
      correctAnswer: 1,
      explanation: "A systematic approach based on the session's teachings leads to consistent results.",
    },
    {
      question: "What should you practice to reinforce this session's concepts?",
      options: [
        "Completely different topics",
        "Similar problems using the covered concepts",
        "Nothing at all",
        "Only the exact same problems",
      ],
      correctAnswer: 1,
      explanation: "Practicing similar problems helps solidify your understanding of the concepts.",
    },
  ];
}

